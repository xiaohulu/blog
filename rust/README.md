# Rust 语言

1. 要详细介绍堆和栈的概念，因为程序的核心是存储数据和修改数据，而堆和栈就是解决如何存储数据的核心概念；
2. 要介绍 rust 中哪些数据放在堆上，哪些数据放在栈上，如
    1. `str` 与 `String` 的区别
    2. 如 `function` 中的参数和局部变量
3. 通过以下代码确认 `str` 是否存在栈上

    ```rust
    let str1 = "hello, world!";
    let str2 = str1;

    ```
4. 所有权系统是对堆和栈概念的又一层封装
5. 要介绍概念的封装，概念的封装是为了让接口更加简洁、清晰，让用户无需关心底层实现的复杂性，概念的抽象和封装并没有减少底层实现的复杂性，只是将暴露给用户的部分，抽象的更加直观，更加容易理解
6. 值的生命周期是由变量（即所有者）控制的，变量的生命周期是由作用域控制的；
7. `mut` 关键字的作用很简单，它是修饰变量的，就是能不能修改变量的值？还是将变量绑定到另一个值上？变量绑定的值不能改变
    1. 存储在栈上的值，不能二次绑定；
    2. 存储在堆上的值，不能修改堆上的值；
8. 在传参时，会涉及到所有权概念，s.push_str("x") 的完整形式是 String::push_str(s, "x")，所以 s 也涉及到借用
9. 我们都知道变量地址、大小和容量存储在栈中，但是变量的名字存储在哪里呢？ https://blog.csdn.net/u012826756/article/details/46859319
10. `Drop` trait 只用来处理堆上的数据
11. `Copy` trait 只用来处理栈上的数据
12. `let s2 = String::from("hello");` from 关联函数将返回值 move 给 s2
13. 引用就是可以使用，但不 move，即不转移所有权
14. 悬垂引用是指将栈和堆上的值的关系解除了，即单独的清理了堆上的值，但没有清理栈上的值
15. 引用可以用在变量赋值上，也可以用到函数传参上，当用到函数的参数上时，被称为借用
16. 使用引用借用的变量，在方法中要修改变量的值，是不是暗中做了解引用？
17. 为什么不会出现悬垂引用？因为数据是否有效，只有变量说了算，并不会出现数据和引用单独清除的情况；
18. 函数的返回值所有权被移出，所以不会释放处于函数内的返回值，因为有所有权就不能释放内存；
19. 即在一个作用域中，同一个值不能既有可变引用也有不可变引用；同时一个作用域一个值只能有一个可变引用；
20. 引用有两种，一种是完整引用一个对象，另一种是引用一个对象中的部分成员；
21. 引用只适用于存储在堆上的对象；
22. slice 是一个没有所有权的类型，存储在栈上的类型都是没有所有权的；
23. 元组类型的形式为 `(u32, u32)`，`let a = [1, 2, 3, 4, 5];` 数组类型的形式为 `[i32; 5]`
24. 字符串字面值就是一个字符串切片，类型表示为 `&str`
25. struts 结构体中有字段的概念
26. struts 中的特殊概念
    1.  结构体更新语法
    2.  字段初始化简写语法
27. 使用结构体创建新类型（结构体即新的数据类型）
    1.  元组结构体
    2.  类单元结构体
    3.  匿名结构体
28. unit 类型 `()`
29. 可以在以下上下文中定义方法：
    1.  结构体
    2.  枚举
    3.  trait
30. 一个输入参数有以下三种情况：
    1.  获取实参的所有权，如 `param`
    2.  不可变的借用实参，如 `&param`
    3.  可变的借用实参，如 `&mut param`
31. 有两类方法调用：
    1.  直接在对象上调用方法
    2.  在一个对象的指针上调用方法
32. 自动引用和解引用是为了让调用方法的实例与方法的函数签名一致
    1.  自动引用，表示自动添加 `&` 或 `&mut`
    2.  自动解引用，表示自动添加 `*`
33. `::` 语法用于
    1.  关联函数（是一个特殊的命名空间，即位于结构体内的）
    2.  由模块创建的命名空间
34. 可以为一个结构体定义多个 `impl` 块
35. 结构中的叫字段，枚举中的叫成员
36. 枚举值：
    1.  枚举值只能是其中一个成员；
    2.  枚举中有成员，每个成员可是不同的类型，并被赋予值
    3.  直接将数据值附加在枚举的每个成员上
37. 如枚举，放在命名空间下的成员都是同一个类型，这样的设计是通用的吗？
38. 


> 软件与运行它们的硬件是完全解耦的
>
> -- 生命 3.0

理论是根据实践总结出来的，但是理论一旦形成，就成为概念和逻辑的推演

为什么喜欢 Rustd，因为 Rust 就是基于这样的理念，为编程语言提供了一个全新的、新颖的探索，它通过一套完美的理论体系（概念），兼顾了快速和安全这两个向来矛盾的概念。

一套好的理论，能让在旧的理论搭建的环境下完全矛盾的概念，在新的理论环境下不再对立，甚至能兼顾，甚至能相辅相成，互相促进。

这样的理论之美，之震撼足以令我等幸福很久，或每每想起就倍感幸福。

这就是我打算学习 Rust 的原因。我也很高兴能在这里跟大家分享我的学习心得。

解决一类问题的一套理论如果过于复杂，则说明这套理论还不够成熟，还有很大演变的空间。


Rust 15秒


所有多走的弯路背后，都是由一个想走直路、捷径的想法驱使的。
要明白路要一步一步走的道理，而真正能做到则需要强大的定力。
如果一段路要走1000步，在走到100步时不要考虑如何下一步走到第900步，只管一步一步走就是了；但也不能就按一开始设计的路径走，一开始只能设定一个大的目标，然后在走的过程中不断优化路径。

有些人发心灵鸡汤，但自己从来不会去执行，只是为了衬托出自己的境界；
而我发的被大家当做鸡汤的东西，其实是在执行的路上的感悟而已。



学会就是为了忘记，比如学习的 rust 的所有权系统后，就可以不用堆和栈的知识了。